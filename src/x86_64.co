import "src/builtins.co" builtins;
import "src/codegen.co" codegen;
import "src/compiler.co" compiler;
import "src/identifier_types.co" itypes;
import "src/tokenizer.co" tokenizer;
import "src/writer.co" writer;

enum {
    rax = 0,
    rcx = 1,
    rdx = 2,
    rbx = 3,
    rsp = 4,
    rbp = 5,
    rsi = 6,
    rdi = 7,
    r8  = 8,
    r9  = 9,
    r10 = 10,
    r11 = 11,
    r12 = 12,
    r13 = 13,
    r14 = 14,
    r15 = 15,
};

fn code8(value) {
    return writer.write_generic(value, writer.text, 1);
}

fn code16(value) {
    return writer.write_generic(value, writer.text, 2);
}

fn code32(value) {
    return writer.write_generic(value, writer.text, 4);
}

fn code64(value) {
    return writer.write_generic(value, writer.text, 8);
}

fn make_rex(W, R, X, B) {
    W <<= 1;
    W |= R;
    W <<= 1;
    W |= X;
    W <<= 1;
    W |= B;
    if(W) {
        W |= 0x40;
        code8(W);
        return;
    } else { return; }
}

fn rexw() {
    make_rex(1, 0, 0, 0);
}

fn rexb() {
    make_rex(0, 0, 0, 1);
}

fn modrm(mod, reg, rm) {
    mod <<= 3;
    mod |= reg;
    mod <<= 3;
    mod |= rm;
    code8(mod);
}

fn rep() {
    code8(0xF3);
}

fn op_size() {
    code8(0x66);
}

fn addr_size() {
    code8(0x67);
}

fn prefixes(opsize, regnum) {
    @assert(regnum < 0x10);

    regnum = regnum >= 8;

    switch(opsize) {
        @todo("x86_64 prefixes bad opsize");
    case 16:
        op_size();
        make_rex(0, 0, 0, regnum);
        return;
    case 32:
        make_rex(0, 0, 0, regnum);
        return;
    case 64:
        make_rex(1, 0, 0, regnum);
        return;
    }
}

fn prefixes_alt(opsize, regnum) {
    @assert(regnum < 0x10);

    regnum = regnum >= 8;

    switch(opsize) {
        @todo("x86_64 prefixes bad opsize");
    case 16:
        op_size();
        make_rex(0, regnum, 0, 0);
        return;
    case 32:
        make_rex(0, regnum, 0, 0);
        return;
    case 64:
        make_rex(1, regnum, 0, 0);
        return;
    }
}

fn movsb() {
    code8(0xA4);
}

fn stosb() {
    code8(0xAA);
}

fn lodsb() {
    code8(0xAC);
}

fn movsw() {
    op_size();
    code8(0xA5);
}

fn stosw() {
    op_size();
    code8(0xAB);
}

fn lodsw() {
    op_size();
    code8(0xAD);
}

fn movsd() {
    code8(0xA5);
}

fn stosd() {
    code8(0xAB);
}

fn lodsd() {
    code8(0xAD);
}

fn movsq() {
    rexw();
    code8(0xA5);
}

fn stosq() {
    rexw();
    code8(0xAB);
}

fn lodsq() {
    rexw();
    code8(0xAD);
}

fn ret() {
    code8(0xC3);
}

fn push_reg(regnum) {
    if(regnum >= 8) {
        rexb();
    } else { }
    regnum &= 0x7;
    regnum |= 0x50;
    code8(regnum);
}

fn pop_reg(regnum) {
    if(regnum >= 8) {
        rexb();
    } else { }
    regnum &= 0x7;
    regnum |= 0x58;
    code8(regnum);
}

fn load_reg_value(regnum, value) {
    prefixes(64, regnum);
    regnum &= 0x7;
    regnum |= 0xB8;
    code8(regnum);
    code64(value);

    return 0;
}

fn write_riprel32_to_here(code_addr) [rip_at_jmp, rel] {
    rip_at_jmp = code_addr + 4;
    rel = writer.code_addr() - rip_at_jmp;
    writer.patch32(rel, writer.text, code_addr);
}

fn ref_riprel32(addr, extra_offset) {
    addr -= writer.code_addr();
    addr -= extra_offset;
    addr -= 4;
    code32(addr);
}

fn jmp_to(addr) {
    // jmp imm32
    code8(0xE9);
    ref_riprel32(addr, 0);
}

fn bitwise_negate() {
    prefixes(64, 0);
    code8(0xF7);
    code8(0xD0);
}

fn neg_offset(offset) {
    offset = -offset;
    code32(offset);
}

fn rmimm_offset_regs(offset, mem_reg, other_reg) {
    mem_reg &= 0x7;
    other_reg &= 0x7;

    other_reg <<= 3;

    mem_reg |= 0x80;
    mem_reg |= other_reg;

    code8(mem_reg);
    code32(offset);
}

fn rmimm_neg_offset_regs(offset, mem_reg, other_reg) {
    offset = -offset;
    rmimm_offset_regs(offset, mem_reg, other_reg);
}

fn load_reg_relative_to_reg(dest_reg, src_reg, offset) {
    // mov dest_reg, [src_reg + offset]
    prefixes(64, 0);
    code8(0x8B);
    rmimm_offset_regs(offset, src_reg, dest_reg);
}

fn load_local_variable(regnum, offset) {
    // mov reg, qword ptr [rbp - offset]
    prefixes_alt(64, regnum);
    code8(0x8B);
    rmimm_neg_offset_regs(offset, rbp, regnum);
}

fn ref_local_variable(regnum, offset) {
    // lea reg, [rbp - offset]
    rexw();
    code8(0x8D);
    regnum <<= 3;
    regnum |= 0x85;
    code8(regnum);
    neg_offset(offset);
}

fn ref_global_variable(regnum, addr) {
    // lea regnum, [rel glob]
    prefixes(64, regnum);
    code8(0x8D);
    regnum &= 0x7;
    regnum <<= 3;
    regnum |= 0x5;
    code8(regnum);
    ref_riprel32(addr, 0);
}

fn load_global_variable(regnum, addr) {
    // mov regnum, [rel glob]
    prefixes(64, regnum);
    code8(0x8B);
    regnum &= 0x7;
    regnum += 0x5;
    code8(regnum);
    ref_riprel32(addr, 0);
}

fn put_value_in_reg(regnum, type, value, is_last_evaluated) {
    switch(type) {
        @todo("put_value_in_reg default type");

    case itypes.local_variable:
        load_local_variable(regnum, value);
        return;

    case itypes.local_buffer_addr:
        ref_local_variable(regnum, value);
        return;

    case itypes.global_variable:
        load_global_variable(regnum, value);
        return;

    case itypes.global_buffer_addr:
    case itypes.function_addr:
        ref_global_variable(regnum, value);
        return;

    case itypes.comptime_int:
        load_reg_value(regnum, value);
        return;

    case itypes.runtime_reference:
        if(is_last_evaluated) {
            load_reg_relative_to_reg(regnum, rax, 0);
            return;
        } else {
            pop_reg(rcx);
            load_reg_relative_to_reg(regnum, rcx, 0);
            return;
        }

    case itypes.runtime_int:
        if(is_last_evaluated) {
            if(regnum) {
                // mov regnum, rax
                prefixes(64, regnum);
                code8(0x89);
                regnum &= 0x7;
                regnum += 0xC0;
                code8(regnum);
                return;
            } else {
                // Value is already in the register it needs to be
                return;
            }
        } else {
            pop_reg(regnum);
            return;
        }
    }
}

fn put_evaluated_in_reg(regnum) [value, type] {
    value = codegen.eval_value[0];
    type = codegen.eval_type[0];
    put_value_in_reg(regnum, type, value, 1);
}

fn put_arg_in_reg(regnum) {
    codegen.eval_returning_expr(codegen.any_unambigous_expr);
    put_evaluated_in_reg(regnum);

    if(codegen.peek_type() == tokenizer.comma) {
        codegen.discard();
    } else { }
}

fn put_opt_arg_in_reg(regnum) {
    if(codegen.peek_type() == tokenizer.closing_paren) {
    } else {
        put_arg_in_reg(regnum);
    }
}

fn do_call_addr(addr) {
    put_opt_arg_in_reg(rdi);
    put_opt_arg_in_reg(rsi);
    put_opt_arg_in_reg(rdx);
    put_opt_arg_in_reg(rcx);
    put_opt_arg_in_reg(r8);
    put_opt_arg_in_reg(r9);

    // call imm32
    code8(0xE8);
    ref_riprel32(addr, 0);
}

fn return_evaluated() [value, type] {
    put_evaluated_in_reg(rax);

    // value = codegen.eval_value[0];

    // switch(codegen.eval_type[0]) {
    //     @todo("x86_64 return_evaluated default");

    // case itypes.local_variable:
    //     load_local_variable(rax, value);
    //     endcase;

    // case itypes.global_variable:
    //     load_global_variable(rax, value);
    //     endcase;

    // case itypes.comptime_int:
    //     load_reg_value(rax, value);

    //     endcase;

    // case itypes.runtime_reference:
    //     load_reg_relative_to_reg(rax, rax, 0);

    // case itypes.runtime_int:
    //     // We're already done, as the value already is in rax
    // }

    // mov rsp, rbp
    rexw();
    code8(0x89);
    code8(0xEC);

    pop_reg(rbp);

    ret();
}

fn function_prologue(num_args, local_var_space, stack_frame_size) {
    push_reg(rbp);

    // mov rbp, rsp
    code8(0x48);
    code8(0x89);
    code8(0xE5);

    // We don't have arrays yet so this will have to do for now
    if(num_args >= 1) {
        push_reg(rdi);
        if(num_args >= 2) {
            push_reg(rsi);
            if(num_args >= 3) {
                push_reg(rdx);
                if(num_args >= 4) {
                    push_reg(rcx);
                    if(num_args >= 5) {
                        push_reg(r8);
                        if(num_args >= 6) {
                            push_reg(r9);
                            if(num_args >= 7) {
                                @todo("x86_64 too many args");
                                unreachable;
                            } else { }
                        } else { }
                    } else { }
                } else { }
            } else { }
        } else { }
    } else { }

    if(local_var_space) {
        // sub rsp, local_var_space
        rexw();
        code8(0x81);
        code8(0xEC);
        code32(local_var_space);
    } else {}
}

fn builtin_memcpy() [tmp] {
    put_arg_in_reg(rdi);
    put_arg_in_reg(rsi);

    codegen.eval_returning_expr(codegen.any_unambigous_expr);

    if(codegen.eval_type[0] == itypes.comptime_int) {
        tmp = codegen.eval_value[0];

        if(tmp <= 24) {
            loop {
                if(tmp >= 8) {
                    movsq();
                    tmp -= 8;
                    continue;
                } else { }
                if(tmp >= 4) {
                    movsd();
                    tmp -= 4;
                } else {}
                if(tmp >= 2) {
                    movsw();
                    tmp -= 2;
                } else {}
                if(tmp >= 1) {
                    movsb();
                    tmp -= 1;
                } else {}
                return;
            }
        } else {
            load_reg_value(rcx, tmp);
        }
    } else {
        put_evaluated_in_reg(rcx);
    }

    rep();
    movsb();
}

fn builtin_memset() [tmp] {
    put_arg_in_reg(rdi);
    put_arg_in_reg(rax);
    put_arg_in_reg(rcx);

    rep();
    stosb();
}

fn jmp_riprel8(offset) {
    code8(0xEB);
    code8(offset);
}

fn jmp_riprel32(offset) {
    code8(0xE9);
    code32(offset);
}

fn builtin_syscall() {
    put_arg_in_reg(rax);
    put_opt_arg_in_reg(rdi);
    put_opt_arg_in_reg(rsi);
    put_opt_arg_in_reg(rdx);
    put_opt_arg_in_reg(r10);
    put_opt_arg_in_reg(r8);
    put_opt_arg_in_reg(r9);

    code8(0x0F);
    code8(0x05);
}

fn builtin_call() {
    put_arg_in_reg(rax);
    put_opt_arg_in_reg(rdi);
    put_opt_arg_in_reg(rsi);
    put_opt_arg_in_reg(rdx);
    put_opt_arg_in_reg(rcx);
    put_opt_arg_in_reg(r8);
    put_opt_arg_in_reg(r9);

    // call rax
    code8(0xFF);
    code8(0xD0);
}

fn make_switch() [switch_table_addr] {
    switch_table_addr = writer.section_addr(writer.rodata);

    put_evaluated_in_reg(rax);
    ref_global_variable(rdx, switch_table_addr);

    // mov eax, [rdx + rax * 4]
    code8(0x8B);
    code8(0x04);
    code8(0x82);

    // TODO: Skip this if not PIC AND executable base below 4G {
        // lea rdx, [rel l]
        rexw();
        code8(0x8D);
        code8(0x15);
        code32(0x0A);

        // add rax, rdx
        rexw();
        code8(0x01);
        code8(0xD0);
    // }

    // jmp rax
    code8(0xFF);
    code8(0xE0);

    // jmp imm32
    code8(0xE9);
    code32(0x41414141);

    // l:

    return writer.code_addr() - 5;
}

fn endcase_to_here(endcase_addr) {
    endcase_addr += 1;
    write_riprel32_to_here(endcase_addr);
}

fn make_loop_break() {
    jmp_riprel8(5); // Jump past next jmp

    jmp_riprel32(0x41414141);

    return writer.code_addr() - 5;
}

fn loop_break_to_here(loop_break) {
    loop_break += 1;
    write_riprel32_to_here(loop_break);
}

fn if_condition() [value] {
    value = codegen.eval_value[0];

    switch(codegen.eval_type[0]) {
        @todo("x86_64 if condition default");

    case itypes.local_variable:
        // cmp qword ptr[rbp - offset], 0
        value = -value;
        prefixes(64, rbp);
        code8(0x83);
        code8(0xBD);
        code32(value);
        code8(0);

        // je else_case
        code8(0x0F);
        code8(0x84);
        code32(0x41414141);

        return writer.code_addr() - 4;

    case itypes.global_variable:
        // cmp qword ptr [rel glob], 0
        rexw();
        code8(0x83);
        code8(0x3D);
        ref_riprel32(value, 1);
        code8(0);

        // je else_case
        code8(0x0F);
        code8(0x84);
        code32(0x41414141);

        return writer.code_addr() - 4;

    case itypes.runtime_reference:
        // mov rax, [rax]
        load_reg_relative_to_reg(rax, rax, 0);

    case itypes.runtime_int:
        // test rax, rax
        rexw();
        code8(0x85);
        code8(0xC0);

        // jz else_case
        code8(0x0F);
        code8(0x84);
        code32(0x41414141);

        return writer.code_addr() - 4;
    }
}

fn else_block_start(not_taken_fixup) {
    // Argument is the value returned from above

    // jmp endif
    code8(0xE9);
    code32(0x41414141);

    // Fixup else branch to here
    write_riprel32_to_here(not_taken_fixup);

    return writer.code_addr() - 4;
}

fn else_block_end(jmp_end_fixup) {
    write_riprel32_to_here(jmp_end_fixup);
}

fn store_local_variable(regnum, offset) {
    // mov [rbp - offset], regnum
    rexw();
    code8(0x89);
    rmimm_neg_offset_regs(offset, rbp, regnum);
}

fn save_eval_value() {
    push_reg(rax);
}

fn add_elf_entry_point(main) [retval] {
    retval = writer.code_addr();

    // argc = [rsp]
    // mov rdi, qword ptr [rsp]
    rexw();
    code8(0x8B);
    code8(0x3C);
    code8(0x24);

    // argv = rsp + 8
    // lea rsi, [rsp + 8]
    rexw();
    code8(0x8D);
    code8(0x74);
    code8(0x24);
    code8(0x08);

    // envp = rsp + (argc + 1) * 8 + 0x8
    // lea rdx, [rsp + rdi * 8 + 0x10]
    rexw();
    code8(0x8D);
    code8(0x54);
    code8(0xFC);
    code8(0x10);

    jmp_to(main);

    return retval;
}

fn jmp_to_assert_fail() [addr] {
    addr = compiler.assert_fail_addr();
    jmp_to(addr);
}

fn insert_assert_fail_offset(extra_offset) [addr] {
    addr = compiler.assert_fail_addr();
    ref_riprel32(addr, extra_offset);
}

fn builtin_todo() {
    put_opt_arg_in_reg(rdi);
    load_reg_value(rsi, 0);
    load_reg_value(rdx, 0);

    codegen.expr_returns[0] = 0;

    jmp_to_assert_fail();
}

fn builtin_panic() {
    put_opt_arg_in_reg(rdi);
    load_reg_value(rsi, 0);
    load_reg_value(rdx, 0);

    codegen.expr_returns[0] = 0;

    jmp_to_assert_fail();
}

fn builtin_assert() {
    codegen.eval_expr(codegen.any_unambigous_expr);
    put_evaluated_in_reg(rax);
    put_opt_arg_in_reg(rdi);
    load_reg_value(rsi, 0);
    load_reg_value(rdx, 0);

    // test rax, rax
    rexw();
    code8(0x85);
    code8(0xC0);

    // jz assert_fail
    code8(0x0F);
    code8(0x84);
    insert_assert_fail_offset(0);
}

fn builtin_write8() {
    put_arg_in_reg(rdi);
    put_arg_in_reg(rax);
    stosb();
}

fn builtin_write16() {
    put_arg_in_reg(rdi);
    put_arg_in_reg(rax);
    stosw();
}

fn builtin_write32() {
    put_arg_in_reg(rdi);
    put_arg_in_reg(rax);
    stosd();
}

fn builtin_read8() {
    put_arg_in_reg(rsi);
    load_reg_value(rax, 0); // Clear upper bits
    lodsb();
}

fn builtin_read16() {
    put_arg_in_reg(rsi);
    load_reg_value(rax, 0); // Clear upper bits
    lodsw();
}

fn builtin_read32() {
    put_arg_in_reg(rsi);
    load_reg_value(rax, 0); // Clear upper bits
    lodsd();
}

fn do_unary_op(op, operand_type, operand_value) {
    // The operand can't be of type comptime_int. If it is the value should already be known
    @assert(operand_type != itypes.comptime_int);

    put_value_in_reg(rax, operand_type, operand_value, 1);

    switch(op) {
        @todo("x86_64 do_unary_op default");
    case tokenizer.subtraction:
        // neg rax
        rexw();
        code8(0xF7);
        code8(0xD8);
        return;

    case tokenizer.bitnot:
        // not rax
        rexw();
        code8(0xF7);
        code8(0xD0);
        return;
    }
}

fn do_binary_op(lhs_type, lhs_value, op, rhs_type, rhs_value) {
    switch(lhs_type) {
        endcase;

    case itypes.comptime_int:
        // Just load them into registers, can't do much about that.
        load_reg_value(rcx, lhs_value);
        lhs_type = itypes.runtime_int;
        endcase;

    case itypes.runtime_reference:
        if(codegen.lhs_not_saved(lhs_type, rhs_type)) {
            load_reg_relative_to_reg(rax, rax, 0); // deref it
        } else {
            pop_reg(rcx);
            load_reg_relative_to_reg(rcx, rcx, 0); // deref it
        }
        lhs_type = itypes.runtime_int;
        endcase;

    case itypes.runtime_int:
        if(codegen.lhs_not_saved(lhs_type, rhs_type)) {
        } else {
            pop_reg(rcx);
        }
        // endcase;
    }

    if(rhs_type == itypes.comptime_int) {
        switch(op) {
            @todo("x86_64 do_binary_op comptime default op");

        case tokenizer.addition:
            put_value_in_reg(rax, lhs_type, lhs_value, 1);
            if((rhs_value <= 0x7FFFFFFF) | (rhs_value >= 0xFFFFFFFF80000000)) {
                // add rax, imm32
                rexw();
                code8(0x05);
                code32(rhs_value);
                return;
            } else {
                @todo("x86_64 do_binary_op comptime addition large");
            }

        case tokenizer.subtraction:
            put_value_in_reg(rax, lhs_type, lhs_value, 1);
            if((rhs_value <= 0x7FFFFFFF) | (rhs_value >= 0xFFFFFFFF80000000)) {
                // sub rax, imm32
                rexw();
                code8(0x2D);
                code32(rhs_value);
                return;
            } else {
                @todo("x86_64 do_binary_op comptime subtraction large");
            }

        case tokenizer.multiplication:
            put_value_in_reg(rax, lhs_type, lhs_value, 1);
            if(rhs_value == 8) { // Most common multiplication is by 8 (in array subscript)
                // shl rax, 3
                rexw();
                code8(0xC1);
                code8(0xE0);
                code8(0x03);
                return;
            } else {
                load_reg_value(rcx, rhs_value);
                // mul rcx
                rexw();
                code8(0xF7);
                code8(0xE1);
                return;
            }

        case tokenizer.modulus:
            @todo("x86_64 do_binary_op comptime modulus");

        case tokenizer.bitor:
            @todo("x86_64 do_binary_op comptime bitor");

        case tokenizer.bitand:
            @todo("x86_64 do_binary_op comptime bitand");

        case tokenizer.bitxor:
            @todo("x86_64 do_binary_op comptime bitxor");

        case tokenizer.less_than:
        case tokenizer.less_than_equal:
        case tokenizer.greater_than:
        case tokenizer.greater_than_equal:
        case tokenizer.equals:
        case tokenizer.not_equals:
            switch(lhs_type) {
                @todo("x86_64 do_binary_op comptime compare default lhs");

            case itypes.runtime_reference:
                load_reg_relative_to_reg(rax, rax, 0);
                if((rhs_value <= 0x7FFFFFFF) | (rhs_value >= 0xFFFFFFFF80000000)) {
                    // cmp rax, imm32
                    rexw();
                    code8(0x3D);
                    code32(rhs_value);
                    endcase;
                } else {
                    @todo("x86_64 do_binary_op comptime compare runtime_reference large");
                }


            case itypes.runtime_int:
                if((rhs_value <= 0x7FFFFFFF) | (rhs_value >= 0xFFFFFFFF80000000)) {
                    // cmp rax, imm32
                    rexw();
                    code8(0x3D);
                    code32(rhs_value);
                    endcase;
                } else {
                    @todo("x86_64 do_binary_op comptime compare runtime_int large");
                }

            case itypes.local_variable:
                if((rhs_value <= 0x7FFFFFFF) | (rhs_value >= 0xFFFFFFFF80000000)) {
                    // cmp [rbp - offset], imm32
                    rexw();
                    code8(0x81);
                    code8(0xBD);
                    neg_offset(lhs_value);
                    code32(rhs_value);
                    endcase;
                } else {
                    @todo("x86_64 do_binary_op comptime compare local_variable large");
                }

            case itypes.global_variable:
                if((rhs_value <= 0x7FFFFFFF) | (rhs_value >= 0xFFFFFFFF80000000)) {
                    // cmp [rel glob], imm32
                    rexw();
                    code8(0x81);
                    code8(0x3D);
                    ref_riprel32(lhs_value, 4);
                    code32(rhs_value);
                    endcase;
                } else {
                    @todo("x86_64 do_binary_op comptime compare global_variable large");
                }
            }
            // endcase;
        }
    } else {
        switch(op) {
            @todo("x86_64 do_binary_op runtime default op");

        case tokenizer.modulus:
        case tokenizer.division:
            load_reg_value(rdx, 0); // Upper half
        case tokenizer.addition:
        case tokenizer.subtraction:
        case tokenizer.multiplication:
        case tokenizer.bitand:
        case tokenizer.bitor:
        case tokenizer.bitxor:
        case tokenizer.shift_left:
        case tokenizer.shift_right:
            put_value_in_reg(rcx, rhs_type, rhs_value, 1);
            put_value_in_reg(rax, lhs_type, lhs_value, 0);
            endcase;

        case tokenizer.less_than:
        case tokenizer.less_than_equal:
        case tokenizer.greater_than:
        case tokenizer.greater_than_equal:
        case tokenizer.equals:
        case tokenizer.not_equals:
            switch(lhs_type) {
                @todo("x86_64 do_inplace_op runtime compare default lhs");

            case itypes.runtime_int:
                put_value_in_reg(rcx, lhs_type, lhs_value, 1);
                put_value_in_reg(rax, rhs_type, rhs_value, 1);

                // cmp rcx, rax
                rexw();
                code8(0x39);
                code8(0xC1);
                endcase;

            case itypes.local_variable:
                put_value_in_reg(rax, rhs_type, rhs_value, 1);
                // cmp [rbp - offset], rax
                rexw();
                code8(0x39);
                rmimm_neg_offset_regs(lhs_value, rbp, rax);
                // endcase;
            }
            // endcase;
        }

    }

    switch(op) {
    case tokenizer.addition:
        // add rax, rcx
        rexw();
        code8(0x01);
        code8(0xC8);
        return;

    case tokenizer.subtraction:
        // sub rax, rcx
        rexw();
        code8(0x29);
        code8(0xC8);
        return;

    case tokenizer.multiplication:
        // mul rcx
        rexw();
        code8(0xF7);
        code8(0xE1);
        return;

    case tokenizer.modulus:
        // div rcx
        rexw();
        code8(0xF7);
        code8(0xF1);

        // mov rax, rdx
        rexw();
        code8(0x89);
        code8(0xD0);
        return;

    case tokenizer.division:
        // div rcx
        rexw();
        code8(0xF7);
        code8(0xF1);
        return;

    case tokenizer.bitand:
        // and rax, rcx
        rexw();
        code8(0x21);
        code8(0xC8);
        return;

    case tokenizer.bitor:
        // or rax, rcx
        rexw();
        code8(0x09);
        code8(0xC8);
        return;

    case tokenizer.bitxor:
        // xor rax, rcx
        rexw();
        code8(0x31);
        code8(0xC8);
        return;

    case tokenizer.shift_left:
        @todo("shl rax, cl");

    case tokenizer.shift_right:
        @todo("shr rax, cl");

    case tokenizer.less_than:
        // setb al
        code8(0x0F);
        code8(0x92);
        code8(0xC0);
        endcase;

    case tokenizer.greater_than_equal:
        // setae al
        code8(0x0F);
        code8(0x93);
        code8(0xC0);
        endcase;

    case tokenizer.equals:
        // sete al
        code8(0x0F);
        code8(0x94);
        code8(0xC0);
        endcase;

    case tokenizer.not_equals:
        // setne al
        code8(0x0F);
        code8(0x95);
        code8(0xC0);
        endcase;

    case tokenizer.less_than_equal:
        // setbe al
        code8(0x0F);
        code8(0x96);
        code8(0xC0);
        endcase;

    case tokenizer.greater_than:
        // seta al
        code8(0x0F);
        code8(0x97);
        code8(0xC0);
        // endcase;
    }

    // movzx rax, al
    rexw();
    code8(0x0F);
    code8(0xB6);
    code8(0xC0);
    return;
}

fn do_inplace_op(lhs_type, lhs_value, op, rhs_type, rhs_value) {
    if(rhs_type == itypes.comptime_int) {
        switch(op) {
            @todo("x86_64 do_inplace_op comptime default op");

        case tokenizer.assignment:
            switch(lhs_type) {
            case itypes.global_variable:
                if((rhs_value <= 0x7FFFFFFF) | (rhs_value >= 0xFFFFFFFF80000000)) {
                    // mov qword ptr [rbp - offset], imm32
                    rexw();
                    code8(0xC7);
                    code8(0x05);
                    ref_riprel32(lhs_value, 4);
                    code32(rhs_value);
                    return;
                } else {
                    @todo("x86_64 do_inplace_op comptime assignment global_variable large");
                }

            case itypes.local_variable:
                if((rhs_value <= 0x7FFFFFFF) | (rhs_value >= 0xFFFFFFFF80000000)) {
                    // mov qword ptr [rbp - offset], imm32
                    rexw();
                    code8(0xC7);
                    code8(0x85);
                    neg_offset(lhs_value);
                    code32(rhs_value);
                    return;
                } else {
                    @todo("x86_64 do_inplace_op comptime assignment local_variable large");
                }

            case itypes.runtime_reference:
                if((rhs_value <= 0x7FFFFFFF) | (rhs_value >= 0xFFFFFFFF80000000)) {
                    @assert(codegen.lhs_not_saved(lhs_type, rhs_type));

                    // mov qword[rax], imm32
                    rexw();
                    code8(0xC7);
                    code8(0x00);
                    code32(rhs_value);
                    return;
                } else {
                    @todo("x86_64 do_inplace_op comptime assignment runtime_reference large");
                }
            }

        case tokenizer.addition_inplace:
            switch(lhs_type) {
            case itypes.global_variable:
                if((rhs_value <= 0x7FFFFFFF) | (rhs_value >= 0xFFFFFFFF80000000)) {
                    // add qword ptr [rel glob], imm32
                    rexw();
                    code8(0x81);
                    code8(0x05);
                    ref_riprel32(lhs_value, 4);
                    code32(rhs_value);
                    return;
                } else {
                    @todo("x86_64 do_inplace_op comptime addition global_variable large");
                }

            case itypes.local_variable:
                if((rhs_value <= 0x7FFFFFFF) | (rhs_value >= 0xFFFFFFFF80000000)) {
                    // add qword ptr [rbp - offset], imm32
                    rexw();
                    code8(0x81);
                    code8(0x85);
                    neg_offset(lhs_value);
                    code32(rhs_value);
                    return;
                } else {
                    @todo("x86_64 do_inplace_op comptime addition local_variable large");
                }

            case itypes.runtime_reference:
                if((rhs_value <= 0x7FFFFFFF) | (rhs_value >= 0xFFFFFFFF80000000)) {
                    @assert(codegen.lhs_not_saved(lhs_type, rhs_type));

                    // add qword[rax], imm32
                    rexw();
                    code8(0x81);
                    code8(0x00);
                    code32(rhs_value);
                    return;
                } else {
                    @todo("x86_64 do_inplace_op comptime addition runtime_reference large");
                }
            }

        case tokenizer.subtraction_inplace:
            switch(lhs_type) {
            case itypes.global_variable:
                if((rhs_value <= 0x7FFFFFFF) | (rhs_value >= 0xFFFFFFFF80000000)) {
                    // sub qword ptr [rel glob], imm32
                    rexw();
                    code8(0x81);
                    code8(0x2D);
                    ref_riprel32(lhs_value, 4);
                    code32(rhs_value);
                    return;
                } else {
                    @todo("x86_64 do_inplace_op comptime subtraction global_variable large");
                }

            case itypes.local_variable:
                if((rhs_value <= 0x7FFFFFFF) | (rhs_value >= 0xFFFFFFFF80000000)) {
                    // sub qword ptr [rbp - offset], imm32
                    rexw();
                    code8(0x81);
                    code8(0xAD);
                    neg_offset(lhs_value);
                    code32(rhs_value);
                    return;
                } else {
                    @todo("x86_64 do_inplace_op comptime subtraction local_variable large");
                }

            case itypes.runtime_reference:
                if((rhs_value <= 0x7FFFFFFF) | (rhs_value >= 0xFFFFFFFF80000000)) {
                    @assert(codegen.lhs_not_saved(lhs_type, rhs_type));

                    // sub qword[rax], imm32
                    rexw();
                    code8(0x81);
                    code8(0x28);
                    code32(rhs_value);
                    return;
                } else {
                    @todo("x86_64 do_inplace_op comptime subtraction runtime_reference large");
                }
            }

        case tokenizer.bitand_inplace:
            switch(lhs_type) {
            case itypes.global_variable:
                if((rhs_value <= 0x7FFFFFFF) | (rhs_value >= 0xFFFFFFFF80000000)) {
                    // and qword ptr [rel glob], imm32
                    rexw();
                    code8(0x81);
                    code8(0x25);
                    ref_riprel32(lhs_value, 4);
                    code32(rhs_value);
                    return;
                } else {
                    @todo("x86_64 do_inplace_op comptime bitand local_variable large");
                }

            case itypes.local_variable:
                if((rhs_value <= 0x7FFFFFFF) | (rhs_value >= 0xFFFFFFFF80000000)) {
                    // and qword ptr [rbp - offset], imm32
                    rexw();
                    code8(0x81);
                    code8(0xA5);
                    neg_offset(lhs_value);
                    code32(rhs_value);
                    return;
                } else {
                    @todo("x86_64 do_inplace_op comptime bitand local_variable large");
                }

            case itypes.runtime_reference:
                @todo("x86_64 do_inplace_op comptime bitand runtime_reference");
            }

        case tokenizer.bitor_inplace:
            switch(lhs_type) {
            case itypes.global_variable:
                if((rhs_value <= 0x7FFFFFFF) | (rhs_value >= 0xFFFFFFFF80000000)) {
                    // or qword ptr [rel glob], imm32
                    rexw();
                    code8(0x81);
                    code8(0x0D);
                    ref_riprel32(lhs_value, 4);
                    code32(rhs_value);
                    return;
                } else {
                    @todo("x86_64 do_inplace_op comptime bitor global_variable large");
                }

            case itypes.local_variable:
                if((rhs_value <= 0x7FFFFFFF) | (rhs_value >= 0xFFFFFFFF80000000)) {
                    // or qword ptr [rbp - offset], imm32
                    rexw();
                    code8(0x81);
                    code8(0x8D);
                    neg_offset(lhs_value);
                    code32(rhs_value);
                    return;
                } else {
                    @todo("x86_64 do_inplace_op comptime bitor local_variable large");
                }

            case itypes.runtime_reference:
                if((rhs_value <= 0x7FFFFFFF) | (rhs_value >= 0xFFFFFFFF80000000)) {
                    @assert(codegen.lhs_not_saved(lhs_type, rhs_type));

                    // or qword[rax], imm32
                    rexw();
                    code8(0x81);
                    code8(0x08);
                    code32(rhs_value);
                    return;
                } else {
                    @todo("x86_64 do_inplace_op comptime bitor runtime_reference large");
                }
            }


        case tokenizer.shift_right_inplace:
            switch(lhs_type) {
            case itypes.global_variable:
                @todo("x86_64 do_inplace_op comptime shift_right global_variable");

            case itypes.local_variable:
                // shr qword[rbp - offset], rhs_value
                rexw();
                code8(0xC1);
                code8(0xAD);
                neg_offset(lhs_value, 1);
                code8(rhs_value);
                return;

            case itypes.runtime_reference:
                @todo("x86_64 do_inplace_op comptime shift_right runtime_reference");
            }

        case tokenizer.shift_left_inplace:
            switch(lhs_type) {
            case itypes.global_variable:
                // shl qword[rel glob], rhs_value
                rexw();
                code8(0xC1);
                code8(0x25);
                ref_riprel32(lhs_value, 1);
                code8(rhs_value);
                return;

            case itypes.local_variable:
                // shl qword[rbp - offset], rhs_value
                rexw();
                code8(0xC1);
                code8(0xA5);
                neg_offset(lhs_value);
                code8(rhs_value);
                return;

            case itypes.runtime_reference:
                @assert(codegen.lhs_not_saved(lhs_type, rhs_type));

                // shl [rax], rhs_value
                rexw();
                code8(0xC1);
                code8(0x20);
                code8(rhs_value);
                return;
            }

        case tokenizer.modulus_inplace:
            switch(lhs_type) {
            case itypes.global_variable:
                @todo("x86_64 do_inplace_op comptime modulus global_variable");

            case itypes.local_variable:
                load_reg_value(rdx, 0); // Upper half
                load_local_variable(rax, lhs_value); // Lower half
                load_reg_value(rcx, rhs_value);

                // div rcx
                rexw();
                code8(0xF7);
                code8(0xF1);

                store_local_variable(rdx, lhs_value);
                return;

            case itypes.runtime_reference:
                @todo("x86_64 do_inplace_op comptime modulus runtime_reference");
            }

        case tokenizer.division_inplace:
            switch(lhs_type) {
            case itypes.global_variable:
                @todo("x86_64 do_inplace_op comptime division global_variable");

            case itypes.local_variable:
                load_reg_value(rdx, 0); // Upper half
                load_local_variable(rax, lhs_value); // Lower half
                load_reg_value(rcx, rhs_value);

                // div rcx
                rexw();
                code8(0xF7);
                code8(0xF1);

                store_local_variable(rax, lhs_value);
                return;

            case itypes.runtime_reference:
                @todo("x86_64 do_inplace_op comptime division runtime_reference");
            }

        case tokenizer.multiplication_inplace:
            switch(lhs_type) {
            case itypes.global_variable:
                load_global_variable(rax, lhs_value);
                load_reg_value(rcx, rhs_value);

                // mul rcx
                rexw();
                code8(0xF7);
                code8(0xE1);

                do_inplace_op(itypes.global_variable, lhs_value, tokenizer.assignment, itypes.runtime_int);
                return;

            case itypes.local_variable:
                load_local_variable(rax, lhs_value);
                load_reg_value(rcx, rhs_value);

                // mul rcx
                rexw();
                code8(0xF7);
                code8(0xE1);

                store_local_variable(rax, lhs_value);
                return;

            case itypes.runtime_reference:
                @todo("x86_64 do_inplace_op comptime multiplication runtime_reference");
            }
        }
    } else {
        put_evaluated_in_reg(rax);
        switch(op) {
            @todo("x86_64 do_inplace_op runtime default op");

        case tokenizer.assignment:
            switch(lhs_type) {
            case itypes.global_variable:
                // mov [rel glob], rax
                rexw();
                code8(0x89);
                code8(0x05);
                ref_riprel32(lhs_value, 0);
                return;

            case itypes.local_variable:    
                store_local_variable(rax, lhs_value);
                return;

            case itypes.runtime_reference:
                pop_reg(rcx);

                // mov [rcx], rax
                rexw();
                code8(0x89);
                code8(0x01);
                return;
            }

        case tokenizer.addition_inplace:
            switch(lhs_type) {
            case itypes.global_variable:
                // add [rel glob], rax
                rexw();
                code8(0x01);
                code8(0x05);
                ref_riprel32(lhs_value, 0);
                return;

            case itypes.local_variable:
                // add [rbp - offset], rax
                rexw();
                code8(0x01);
                rmimm_neg_offset_regs(lhs_value, rbp, rax);
                return;

            case itypes.runtime_reference:
                pop_reg(rcx);

                // add [rcx], rax
                rexw();
                code8(0x01);
                code8(0x01);
                return;
            }

        case tokenizer.subtraction_inplace:
            switch(lhs_type) {
            case itypes.global_variable:
                // sub [rel glob], rax
                rexw();
                code8(0x29);
                code8(0x05);
                ref_riprel32(lhs_value, 0);
                return;

            case itypes.local_variable:
                // sub [rbp - offset], rax
                rexw();
                code8(0x29);
                rmimm_neg_offset_regs(lhs_value, rbp, rax);
                return;

            case itypes.runtime_reference:
                pop_reg(rcx);

                // sub [rcx], rax
                rexw();
                code8(0x29);
                code8(0x01);
                return;
            }

        case tokenizer.bitor_inplace:
            switch(lhs_type) {
            case itypes.global_variable:
                // or [rel glob], rax
                rexw();
                code8(0x09);
                code8(0x05);
                ref_riprel32(lhs_value, 0);
                return;

            case itypes.local_variable:
                // or [rbp - offset], rax
                rexw();
                code8(0x09);
                rmimm_neg_offset_regs(lhs_value, rbp, rax);
                return;

            case itypes.runtime_reference:
                pop_reg(rcx);

                // or [rcx], rax
                rexw();
                code8(0x09);
                code8(0x01);
                return;
            }

        case tokenizer.bitand_inplace:
            switch(lhs_type) {
            case itypes.global_variable:
                // and [rel glob], rax
                rexw();
                code8(0x21);
                code8(0x05);
                ref_riprel32(lhs_value, 0);
                return;

            case itypes.local_variable:
                // and [rbp - offset], rax
                rexw();
                code8(0x21);
                rmimm_neg_offset_regs(lhs_value, rbp, rax);
                return;

            case itypes.runtime_reference:
                pop_reg(rcx);

                // and [rcx], rax
                rexw();
                code8(0x21);
                code8(0x01);
                return;
            }

        case tokenizer.bitxor_inplace:
            switch(lhs_type) {
            case itypes.global_variable:
                // xor [rel glob], rax
                rexw();
                code8(0x31);
                code8(0x05);
                ref_riprel32(lhs_value, 0);
                return;

            case itypes.local_variable:
                // xor [rbp - offset], rax
                rexw();
                code8(0x31);
                rmimm_neg_offset_regs(lhs_value, rbp, rax);
                return;

            case itypes.runtime_reference:
                pop_reg(rcx);

                // xor [rcx], rax
                rexw();
                code8(0x31);
                code8(0x01);
                return;
            }

        case tokenizer.multiplication_inplace:
            switch(lhs_type) {
            case itypes.global_variable:
                @todo("x86_64 do_inplace_op runtime multiplication global_variable");

            case itypes.local_variable:
                load_local_variable(rcx, lhs_value);

                // mul rcx
                rexw();
                code8(0xF7);
                code8(0xE1);

                store_local_variable(rax, lhs_value);
                return;

            case itypes.runtime_reference:
                @todo("x86_64 do_inplace_op runtime multiplication runtime_reference");
            }
        }
    }
}

fn init() {
    // Function prologue and epilogue
    codegen.function_prologue_ptr[0] = function_prologue;
    codegen.return_evaluated_ptr[0] = return_evaluated;
    codegen.add_elf_entry_point_ptr[0] = add_elf_entry_point;

    // Control flow
    codegen.jmp_to_ptr[0] = jmp_to;
    codegen.do_call_addr_ptr[0] = do_call_addr;
    codegen.make_switch_ptr[0] = make_switch;
    codegen.endcase_to_here_ptr[0] = endcase_to_here;
    codegen.make_loop_break_ptr[0] = make_loop_break;
    codegen.loop_break_to_here_ptr[0] = loop_break_to_here;
    codegen.if_condition_ptr[0] = if_condition;
    codegen.else_block_start_ptr[0] = else_block_start;
    codegen.else_block_end_ptr[0] = else_block_end;

    // Expr eval
    codegen.save_eval_value_ptr[0] = save_eval_value;
    codegen.do_unary_op_ptr[0] = do_unary_op;
    codegen.do_binary_op_ptr[0] = do_binary_op;
    codegen.do_inplace_op_ptr[0] = do_inplace_op;

    builtins.add_builtin("memcpy", builtin_memcpy, itypes.builtin_function_codegen);
    builtins.add_builtin("memset", builtin_memset, itypes.builtin_function_codegen);
    builtins.add_builtin("syscall", builtin_syscall, itypes.builtin_function_codegen);
    builtins.add_builtin("call", builtin_call, itypes.builtin_function_codegen);

    builtins.add_builtin("write8", builtin_write8, itypes.builtin_function_codegen);
    builtins.add_builtin("write16", builtin_write16, itypes.builtin_function_codegen);
    builtins.add_builtin("write32", builtin_write32, itypes.builtin_function_codegen);

    builtins.add_builtin("read8", builtin_read8, itypes.builtin_function_codegen);
    builtins.add_builtin("read16", builtin_read16, itypes.builtin_function_codegen);
    builtins.add_builtin("read32", builtin_read32, itypes.builtin_function_codegen);

    builtins.add_builtin("assert", builtin_assert, itypes.builtin_function_codegen);
    builtins.add_builtin("todo", builtin_todo, itypes.builtin_function_codegen);
    builtins.add_builtin("panic", builtin_panic, itypes.builtin_function_codegen);
}
