import "src/builtins.co" builtins;
import "src/codegen.co" codegen;
import "src/identifier_types.co" itypes;
import "src/tokenizer.co" tokenizer;
import "src/writer.co" writer;

enum {
    rax = 0,
    rcx = 1,
    rdx = 2,
    rbx = 3,
    rsp = 4,
    rbp = 5,
    rsi = 6,
    rdi = 7,
    r8  = 8,
    r9  = 9,
    r10 = 10,
    r11 = 11,
    r12 = 12,
    r13 = 13,
    r14 = 14,
    r15 = 15,
};

fn code8(value) {
    return writer.write_generic(value, writer.text, 1);
}

fn code16(value) {
    return writer.write_generic(value, writer.text, 2);
}

fn code32(value) {
    return writer.write_generic(value, writer.text, 4);
}

fn code64(value) {
    return writer.write_generic(value, writer.text, 8);
}

fn make_rex(W, R, X, B) {
    W <<= 1;
    W |= R;
    W <<= 1;
    W |= X;
    W <<= 1;
    W |= B;
    if(W) {
        W |= 0x40;
        code8(W);
        return;
    } else { return; }
}

fn rexw() {
    make_rex(1, 0, 0, 0);
}

fn rexb() {
    make_rex(0, 0, 0, 1);
}

fn modrm(mod, reg, rm) {
    mod <<= 3;
    mod |= reg;
    mod <<= 3;
    mod |= rm;
    code8(mod);
}

fn rep() {
    code8(0xF3);
}

fn op_size() {
    code8(0x66);
}

fn addr_size() {
    code8(0x67);
}

fn prefixes(opsize, regnum) {
    @assert(regnum < 0x10);

    regnum = regnum >= 8;

    switch(opsize) {
        @todo("x86_64 prefixes bad opsize");
    case 16:
        op_size();
        make_rex(0, 0, 0, regnum);
        return;
    case 32:
        make_rex(0, 0, 0, regnum);
        return;
    case 64:
        make_rex(1, 0, 0, regnum);
        return;
    }
}

fn movsb() {
    code8(0xA4);
}

fn movsw() {
    op_size();
    code8(0xA5);
}

fn movsd() {
    code8(0xA5);
}

fn movsq() {
    rexw();
    code8(0xA5);
}

fn ret() {
    code8(0xC3);
}

fn push_reg(regnum) {
    prefixes(64, regnum);
    regnum &= 0x7;
    regnum |= 0x50;
    code8(regnum);
}

fn pop_reg(regnum) {
    prefixes(64, regnum);
    regnum &= 0x7;
    regnum |= 0x58;
    code8(regnum);
}

fn load_reg_value(regnum, value) {
    prefixes(64, regnum);
    regnum &= 0x7;
    regnum |= 0xB8;
    code8(regnum);
    code64(value);

    return 0;
}

fn write_riprel32_to_here(code_addr) [rip_at_jmp, rel] {
    rip_at_jmp = code_addr + 4;
    rel = writer.code_addr() - rip_at_jmp;
    writer.patch32(rel, writer.text, code_addr);
}

fn ref_riprel32(addr, extra_offset) {
    addr -= writer.code_addr() + 4 + extra_offset;
    code32(addr);
}

fn jmp_to(addr) {
    // jmp imm32
    code8(0xE9);
    ref_riprel32(addr, 0);
}

fn return_evaluated() [value] {
    switch(codegen.eval_type[0]) {
        @todo("x86_64 return_evaluated default");

    case itypes.local_variable:
        @todo("x86_64 return_evaluated local_variable");

    case itypes.global_variable:
        @todo("x86_64 return_evaluated global_variable");

    case itypes.comptime_int:
        value = codegen.eval_value[0];
        load_reg_value(rax, value);

        //endcase;

    case itypes.runtime_int:
        // We're already done, as the value already is in rax
    }

    // mov rsp, rbp
    rexw();
    code8(0x89);
    code8(0xEC);

    pop_reg(rbp);

    ret();
}

fn bitwise_negate() {
    prefixes(64, 0);
    code8(0xF7);
    code8(0xD0);
}

fn rmimm_neg_offset_regs(offset, mem_reg, other_reg) {
    mem_reg &= 0x7;
    other_reg &= 0x7;

    other_reg <<= 3;

    mem_reg |= 0x80;
    mem_reg |= other_reg;

    code8(mem_reg);

    offset = -offset;
    code32(offset);
}

fn put_evaluated_in_reg(regnum) [value] {
    value = @read64(codegen.eval_value);

    switch(@read64(codegen.eval_type)) {
        @todo("put_evaluated_in_reg default type");

    case itypes.local_variable:
        // mov reg, qword ptr [rbp - offset]
        prefixes(64, regnum);
        code8(0x8B);
        rmimm_neg_offset_regs(value, rbp, regnum);
        return;

    case itypes.local_buffer_addr:
        @todo("put_evaluated_in_reg local_buffer_addr");

    case itypes.global_variable:
        // mov rax, qword ptr [rel glob]
        rexw();
        code8(0x8B);
        code8(0x05);
        ref_riprel32(value, 0);
        return;

    case itypes.global_buffer_addr:
        // lea reg, [rel global]
        prefixes(64, regnum);
        code8(0x8D);
        code8(0x05);
        ref_riprel32(value, 0);
        return;

    case itypes.comptime_int:
        load_reg_value(regnum, value);
        endcase;

    case itypes.function_addr:
        @todo("put_evaluated_in_reg function_addr");

    case itypes.runtime_int:
        if(regnum) {
            // mov regnum, rax
            prefixes(64, regnum);
            code8(0x89);
            regnum &= 0x7;
            regnum += 0xC0;
            code8(regnum);
        } else {}
    }
}

fn put_arg_in_reg(regnum) {
    codegen.eval_expr();
    put_evaluated_in_reg(regnum);

    if(codegen.peek_type() == tokenizer.comma) {
        codegen.discard();
    } else { }
}

fn put_opt_arg_in_reg(regnum) {
    if(codegen.peek_type() == tokenizer.closing_paren) {
    } else {
        put_arg_in_reg(regnum);
    }
}

fn do_call_addr(addr) {
    put_opt_arg_in_reg(rdi);
    put_opt_arg_in_reg(rsi);
    put_opt_arg_in_reg(rdx);
    put_opt_arg_in_reg(rcx);
    put_opt_arg_in_reg(r8);
    put_opt_arg_in_reg(r9);

    // call imm32
    code8(0xE8);
    ref_riprel32(addr, 0);
}

fn function_prologue(num_args, local_var_space, stack_frame_size) {
    push_reg(rbp);

    // mov rbp, rsp
    code8(0x48);
    code8(0x89);
    code8(0xE5);

    // We don't have arrays yet so this will have to do for now
    if(num_args >= 1) {
        push_reg(rdi);
        if(num_args >= 2) {
            push_reg(rsi);
            if(num_args >= 3) {
                push_reg(rdx);
                if(num_args >= 4) {
                    push_reg(rcx);
                    if(num_args >= 5) {
                        push_reg(r8);
                        if(num_args >= 6) {
                            push_reg(r9);
                            if(num_args >= 7) {
                                @todo("x86_64 too many args");
                                unreachable;
                            } else { }
                        } else { }
                    } else { }
                } else { }
            } else { }
        } else { }
    } else { }

    if(local_var_space) {
        // sub rsp, local_var_space
        rexw();
        code8(0x81);
        code8(0xEC);
        code32(local_var_space);
    } else {}
}

fn builtin_memcpy() [tmp] {
    put_arg_in_reg(rdi);
    put_arg_in_reg(rsi);

    codegen.eval_expr();

    if(@read64(codegen.eval_type) == itypes.comptime_int) {
        tmp = @read64(codegen.eval_value);

        if(tmp <= 24) {
            loop {
                if(tmp >= 8) {
                    movsq();
                    tmp -= 8;
                    continue;
                } else { }
                if(tmp >= 4) {
                    movsd();
                    tmp -= 4;
                } else {}
                if(tmp >= 2) {
                    movsw();
                    tmp -= 2;
                } else {}
                if(tmp >= 1) {
                    movsb();
                    tmp -= 1;
                } else {}
                return;
            }
        } else {
            load_reg_value(rcx, tmp);
        }
    } else {
        put_evaluated_in_reg(rcx);
    }

    rep();
    movsb();
}

fn jmp_riprel8(offset) {
    code8(0xEB);
    code8(offset);
}

fn jmp_riprel32(offset) {
    code8(0xE9);
    code32(offset);
}

fn builtin_syscall() {
    put_arg_in_reg(rax);
    put_opt_arg_in_reg(rdi);
    put_opt_arg_in_reg(rsi);
    put_opt_arg_in_reg(rdx);
    put_opt_arg_in_reg(r10);
    put_opt_arg_in_reg(r8);
    put_opt_arg_in_reg(r9);

    code8(0x0F);
    code8(0x05);
}

fn make_loop_break() {
    jmp_riprel8(5); // Jump past next jmp

    jmp_riprel32(0x41414141);

    return writer.code_addr() - 5;
}

fn if_condition() [value] {
    value = codegen.eval_value[0];

    switch(codegen.eval_type[0]) {
        @todo("x86_64 if condition default");

    case itypes.local_variable:
        // cmp qword ptr[rbp - offset], 0
        value = -value;
        prefixes(64, rbp);
        code8(0x83);
        code8(0xBD);
        code32(value);
        code8(0);

        // je else_case
        code8(0x0F);
        code8(0x84);
        code32(0x41414141);

        return writer.code_addr() - 4;

    case itypes.global_variable:
        // cmp qword ptr [rel glob], 0
        rexw();
        code8(0x83);
        code8(0x3D);
        ref_riprel32(value, 1);
        code8(0);

        // je else_case
        code8(0x0F);
        code8(0x84);
        code32(0x41414141);

        return writer.code_addr() - 4;

    case itypes.runtime_int:
        // test rax, rax
        rexw();
        code8(0x85);
        code8(0xC0);

        // jz else_case
        code8(0x0F);
        code8(0x84);
        code32(0x41414141);

        return writer.code_addr() - 4;
    }
}

fn else_block_start(not_taken_fixup) {
    // Argument is the value returned from above

    // jmp endif
    code8(0xE9);
    code32(0x41414141);

    // Fixup else branch to here
    write_riprel32_to_here(not_taken_fixup);

    return writer.code_addr() - 4;
}

fn else_block_end(jmp_end_fixup) {
    write_riprel32_to_here(jmp_end_fixup);
}

fn do_assignment(lhs_type, lhs_value) {
    // Todo: optimize for comptime known value
    put_evaluated_in_reg(rax);

    switch(lhs_type) {
        @todo("x86_64 assign default");

    case itypes.local_variable:
        // mov [rbp - offset], rax
        rexw();
        code8(0x89);
        rmimm_neg_offset_regs(lhs_value, rbp, rax);
        return;

    case itypes.global_variable:
        // mov [rel glob], rax
        rexw();
        code8(0x89);
        code8(0x05);
        ref_riprel32(lhs_value, 0);
        return;
    }
}

fn do_inplace_add(lhs_type, lhs_value) {
    // Todo: optimize for comptime known value
    put_evaluated_in_reg(rax);

    switch(lhs_type) {
        @todo("x86_64 inplace_add default");

    case itypes.global_variable:
        // add [rel glob], rax
        rexw();
        code8(0x01);
        code8(0x05);
        ref_riprel32(lhs_value, 0);
        return;

    case itypes.local_variable:
        // add [rbp - offset], rax
        rexw();
        code8(0x01);
        rmimm_neg_offset_regs(lhs_value, rbp, rax);
        return;
    }
}

fn do_inplace_sub(lhs_type, lhs_value) {
    // Todo: optimize for comptime known value
    put_evaluated_in_reg(rax);

    switch(lhs_type) {
        @todo("x86_64 inplace_sub default");

    case itypes.local_variable:
        // sub [rbp - offset], rax
        rexw();
        code8(0x29);
        rmimm_neg_offset_regs(lhs_value, rbp, rax);
        return;
    }
}

fn do_inplace_bitand(lhs_type, lhs_value) {
    // Todo: optimize for comptime known value
    put_evaluated_in_reg(rax);

    switch(lhs_type) {
        @todo("x86_64 inplace_sub default");

    case itypes.local_variable:
        // and [rbp - offset], rax
        rexw();
        code8(0x21);
        rmimm_neg_offset_regs(lhs_value, rbp, rax);
        return;
    }
}

fn less_than_runtime(lhs_type, lhs_value) {
    put_evaluated_in_reg(rax); // rhs in rax

    switch(lhs_type) {
        @todo("x86_64 less_than_runtime default lhs");

    case itypes.local_variable:
        // cmp [rbp - offset], rax
        rexw();
        code8(0x39);
        rmimm_neg_offset_regs(lhs_value, rbp, rax);

        // setb al
        code8(0x0F);
        code8(0x92);
        code8(0xC0);

        // movzx rax, al
        rexw();
        code8(0x0F);
        code8(0xB6);
        code8(0xC0);
        return;

    case itypes.global_variable:
        @todo("x86_64 less_than_runtime global_variable");
    }
}

fn equals_runtime_comptime(runtime_type, runtime_value, comptime_value) {
    switch(runtime_type) {
        @todo("x86_64 equals_runtime_comptime default");
    case itypes.local_variable:
        @todo("x86_64 equals_runtime_comptime local_variable");
    case itypes.global_variable:
        if(comptime_value < 0x80000000) { // 32 bit value, TODO: negative values too(?)
            rexw();
            code8(0x81);
            code8(0x3D);
            ref_riprel32(runtime_value, 4);
            code32(comptime_value);
        } else {
            @todo("x86_64 equals_runtime_comptime global_variable large");
        }
    }
}

fn init() {
    // Function prologue and epilogue
    codegen.function_prologue_ptr[0] = function_prologue;
    codegen.return_evaluated_ptr[0] = return_evaluated;

    // Control flow
    codegen.jmp_to_ptr[0] = jmp_to;
    codegen.do_call_addr_ptr[0] = do_call_addr;
    codegen.make_loop_break_ptr[0] = make_loop_break;
    codegen.if_condition_ptr[0] = if_condition;
    codegen.else_block_start_ptr[0] = else_block_start;
    codegen.else_block_end_ptr[0] = else_block_end;

    // Inplace ops
    codegen.do_assignment_ptr[0] = do_assignment;
    codegen.do_inplace_add_ptr[0] = do_inplace_add;
    codegen.do_inplace_sub_ptr[0] = do_inplace_sub;
    codegen.do_inplace_bitand_ptr[0] = do_inplace_bitand;

    // Arith ops
    codegen.less_than_runtime_ptr[0] = less_than_runtime;
    codegen.equals_runtime_comptime_ptr[0] = equals_runtime_comptime;

    // Unary ops
    codegen.bitwise_negate_ptr[0] = bitwise_negate;

    builtins.add_builtin("memcpy", builtin_memcpy, itypes.builtin_function_codegen);
    builtins.add_builtin("syscall", builtin_syscall, itypes.builtin_function_codegen);
}
