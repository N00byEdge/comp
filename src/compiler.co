import "src/builtins.co" builtins;
import "src/codegen.co" codegen;
import "src/identifier_types.co" itypes;
import "src/identifiers.co" idents;
import "src/printer.co" printer;
import "src/source.co" source;
import "src/syscalls.co" syscalls;
import "src/tokenizer.co" tokenizer;
import "src/writer.co" writer;

zeroes import_file_root[8];
zeroes parse_top_level_ptr[8];

fn parse_comptime_decl() [value_node, value] {
    codegen.discard();

    value_node = codegen.expect_token(tokenizer.identifier, "Expected identifier after `comptime`");
    codegen.discard();
    @assert(idents.node_get_type(value_node) == itypes.none);

    codegen.expect_token(tokenizer.assignment, "Expected `=` after identifier");
    codegen.discard();

    value = codegen.eval_comptime_expr(codegen.any_unambigous_expr);
    idents.node_set_value(value_node, value);
    idents.node_set_type(value_node, itypes.comptime_int);

    codegen.expect_token(tokenizer.semicolon, "Expected `;` after comptime declaration");
    codegen.discard();
}

fn parse_enum_decl() [next_value, node] {
    codegen.discard();

    codegen.expect_token(tokenizer.open_curly_brace, "Expected `{` after `enum`");
    codegen.discard();

    next_value = 0;

    loop {
        if(codegen.peek_type() == tokenizer.closing_curly_brace) {
            codegen.discard();
            codegen.expect_token(tokenizer.semicolon, "Expected `;` after enum declaration");
            codegen.discard();
            return;
        } else {
            node = codegen.expect_token(tokenizer.identifier, "Expected identifier or `}`");
            codegen.discard();

            @assert(idents.node_get_type(node) == itypes.none);

            if(codegen.peek_type() != tokenizer.comma) {
                codegen.expect_token(tokenizer.assignment, "Expected `=` or `,` after enum member identifier");
                codegen.discard();
                next_value = codegen.eval_comptime_expr(codegen.any_unambigous_expr);
            } else {}
            idents.node_set_type(node, itypes.comptime_int);
            idents.node_set_value(node, next_value);
            next_value += 1;

            codegen.expect_token(tokenizer.comma, "Expected `,` after enum member value");
            codegen.discard();
            continue;
        }
    }
}

fn set_source_file(file_path) [fd] {
    fd = syscalls.open(file_path, syscalls.O_RDONLY);
    source.switch_file(fd);
}

fn parse_additional_file(file_path, new_node) [fd, root_stash, file_context_stash[source.file_context_size]] {
    // Store our current context, the imported file has no idea!
    root_stash = codegen.current_file_root[0];
    source.stash_file_info(file_context_stash);

    set_source_file(file_path);

    @call(parse_top_level_ptr[0]);

    // Return to monke
    source.restore_file_info(file_context_stash);
    codegen.current_file_root[0] = root_stash;
}

fn parse_file_if_needed(file_path) [node] {
    node = import_file_root[0];
    node = idents.lookup(file_path, node);

    switch(idents.node_get_type(node)) {
        printer.print_string("Bad filename ident type!\n");
        printer.exit(1);

    case itypes.none:
        printer.print_string("Unknown file, let's parse it!\n");

        idents.node_set_type(node, itypes.partially_parsed_filename);

        parse_additional_file(file_path, node);

        idents.node_set_type(node, itypes.fully_parsed_filename);
        return idents.node_get_attribute(node);

    case itypes.fully_parsed_filename:
        printer.print_string("File already parsed, nothing to do\n");
        return idents.node_get_attribute(node);        

    case itypes.partially_parsed_filename:
        printer.print_string("Circular import detected!\n");
        printer.exit(1);
    }
}

fn parse_import() [file_root, ident_node] {
    codegen.discard();

    codegen.expect_token(tokenizer.string_literal, "Expected a string literal after `import`.");
    codegen.discard();
    file_root = parse_file_if_needed(tokenizer.buffer);

    codegen.expect_token(tokenizer.identifier, "Expected an identifier after filename.");
    ident_node = codegen.peek_value();
    codegen.discard();

    // Assert the identifier is unused
    @assert(idents.node_get_type(ident_node) == itypes.none);

    idents.node_set_type(ident_node, itypes.variable_scope);
    idents.node_set_attribute(ident_node, file_root);

    codegen.expect_token(tokenizer.semicolon, "Expected `;` after import");
}

fn add_builtins_to_current_file() [node, builtin_root] {
    node = codegen.current_file_root[0];
    builtin_root = builtins.builtin_root[0];
    node = idents.node_addr(node);
    idents.trie_node_set_next(node, '@', builtin_root);
}

// Parse function argument and local variable list, creating identifiers
// and storing the argument values in their stack slots
fn read_stack_frame() [offset, num, ident, size] {
    offset = 0;

    if(codegen.peek_type() == tokenizer.open_paren) {
        codegen.discard();
        // Parse argument list
        num = 0;

        loop {
            if(codegen.peek_type() == tokenizer.closing_paren) {
                codegen.discard();
                if(num) {
                    codegen.store_args(num);
                } else {}
                break;
            } else {
                ident = codegen.expect_token(tokenizer.identifier, "Expected identifier or `)`");
                codegen.discard();
                @assert(idents.node_get_type(ident) == itypes.none);

                idents.node_set_type(ident, itypes.local_variable);

                offset += 8;

                idents.node_set_value(ident, offset);

                num += 1;
            }

            if(codegen.peek_type() == tokenizer.comma) {
                codegen.discard();
            } else {}
            continue; // @BUG: I need this for some reason.
        }
    } else {}

    if(codegen.peek_type() == tokenizer.open_square_bracket) {
        codegen.discard();
        // Parse local var list
        loop {
            if(codegen.peek_type() == tokenizer.closing_square_bracket) {
                codegen.discard();
                break;
            } else {
                ident = codegen.expect_token(tokenizer.identifier, "Expected identifier or `]`");
                codegen.discard();
                @assert(idents.node_get_type(ident) == itypes.none);

                if(codegen.peek_type() == tokenizer.open_square_bracket) {
                    codegen.discard();

                    idents.node_set_type(ident, itypes.local_buffer);
                    size = codegen.eval_comptime_expr(codegen.any_unambigous_expr);

                    offset += size;
                    idents.node_set_value(ident, offset);
                    idents.node_set_attribute(ident, size);
                } else {
                    idents.node_set_type(ident, itypes.local_variable);

                    offset += 8;
                    idents.node_set_value(ident, offset);
                }
            }

            if(codegen.peek_type() == tokenizer.comma) {
                codegen.discard();
            } else {}
        }
    } else {}
}

fn clear_local_vars_in(node) [i, next] {
    i = 0;

    switch (idents.node_get_type(node)) {
        endcase;
    case itypes.local_variable:
    case itypes.local_buffer:
        idents.node_set_type(node, itypes.none);
        endcase;
    }

    node = idents.node_addr(node);

    loop {
        if(i == idents.max_nexts) {
            return;
        } else {}

        next = idents.trie_node_next(node, i);
        clear_local_vars_in(next);

        i += 1;
    }
}

fn clear_local_vars() [node] {
    node = codegen.current_file_root[0];
    clear_local_vars_in(node);
}

fn parse_function() [fn_ident, root] {
    codegen.discard();

    fn_ident = codegen.expect_token(tokenizer.identifier, "Expected identifier after `fn`");
    codegen.discard();

    read_stack_frame();

    root = codegen.current_file_root[0];
    codegen.parse_block(root);

    clear_local_vars();
}

fn parse_top_level() {
    printer.print_string("Top level!\n");
    codegen.current_file_root[0] = idents.alloc();
    add_builtins_to_current_file();

    loop {
        switch(codegen.peek_type()) {
            @todo("parse_top_level default");

        case tokenizer.keyword_zeroes:
            @todo("parse_top_level zeroes");

        case tokenizer.keyword_fn:
            parse_function();
            continue;

        case tokenizer.keyword_enum:
            parse_enum_decl();
            continue;

        case tokenizer.keyword_comptime:
            parse_comptime_decl();
            continue;

        case tokenizer.keyword_import:
            parse_import();
            continue;
        }
    }
}

fn init(base_addr) {
    idents.init();
    writer.init(base_addr);
    import_file_root[0] = idents.alloc();
    parse_top_level_ptr[0] = parse_top_level;

    builtins.create_builtin_node();
}
